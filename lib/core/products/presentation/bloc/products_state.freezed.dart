// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'products_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ProductsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductsStateCopyWith<$Res> {
  factory $ProductsStateCopyWith(
          ProductsState value, $Res Function(ProductsState) then) =
      _$ProductsStateCopyWithImpl<$Res, ProductsState>;
}

/// @nodoc
class _$ProductsStateCopyWithImpl<$Res, $Val extends ProductsState>
    implements $ProductsStateCopyWith<$Res> {
  _$ProductsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ProductsStateInitImplCopyWith<$Res> {
  factory _$$ProductsStateInitImplCopyWith(_$ProductsStateInitImpl value,
          $Res Function(_$ProductsStateInitImpl) then) =
      __$$ProductsStateInitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProductsStateInitImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateInitImpl>
    implements _$$ProductsStateInitImplCopyWith<$Res> {
  __$$ProductsStateInitImplCopyWithImpl(_$ProductsStateInitImpl _value,
      $Res Function(_$ProductsStateInitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProductsStateInitImpl implements ProductsStateInit {
  const _$ProductsStateInitImpl();

  @override
  String toString() {
    return 'ProductsState.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProductsStateInitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class ProductsStateInit implements ProductsState {
  const factory ProductsStateInit() = _$ProductsStateInitImpl;
}

/// @nodoc
abstract class _$$ProductsStateLoadingImplCopyWith<$Res> {
  factory _$$ProductsStateLoadingImplCopyWith(_$ProductsStateLoadingImpl value,
          $Res Function(_$ProductsStateLoadingImpl) then) =
      __$$ProductsStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProductsStateLoadingImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateLoadingImpl>
    implements _$$ProductsStateLoadingImplCopyWith<$Res> {
  __$$ProductsStateLoadingImplCopyWithImpl(_$ProductsStateLoadingImpl _value,
      $Res Function(_$ProductsStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProductsStateLoadingImpl implements ProductsStateLoading {
  const _$ProductsStateLoadingImpl();

  @override
  String toString() {
    return 'ProductsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ProductsStateLoading implements ProductsState {
  const factory ProductsStateLoading() = _$ProductsStateLoadingImpl;
}

/// @nodoc
abstract class _$$ProductsStateErrorImplCopyWith<$Res> {
  factory _$$ProductsStateErrorImplCopyWith(_$ProductsStateErrorImpl value,
          $Res Function(_$ProductsStateErrorImpl) then) =
      __$$ProductsStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String messages});
}

/// @nodoc
class __$$ProductsStateErrorImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateErrorImpl>
    implements _$$ProductsStateErrorImplCopyWith<$Res> {
  __$$ProductsStateErrorImplCopyWithImpl(_$ProductsStateErrorImpl _value,
      $Res Function(_$ProductsStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = null,
  }) {
    return _then(_$ProductsStateErrorImpl(
      null == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ProductsStateErrorImpl implements ProductsStateError {
  const _$ProductsStateErrorImpl(this.messages);

  @override
  final String messages;

  @override
  String toString() {
    return 'ProductsState.error(messages: $messages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateErrorImpl &&
            (identical(other.messages, messages) ||
                other.messages == messages));
  }

  @override
  int get hashCode => Object.hash(runtimeType, messages);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateErrorImplCopyWith<_$ProductsStateErrorImpl> get copyWith =>
      __$$ProductsStateErrorImplCopyWithImpl<_$ProductsStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return error(messages);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return error?.call(messages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(messages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ProductsStateError implements ProductsState {
  const factory ProductsStateError(final String messages) =
      _$ProductsStateErrorImpl;

  String get messages;
  @JsonKey(ignore: true)
  _$$ProductsStateErrorImplCopyWith<_$ProductsStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateSuccessImplCopyWith<$Res> {
  factory _$$ProductsStateSuccessImplCopyWith(_$ProductsStateSuccessImpl value,
          $Res Function(_$ProductsStateSuccessImpl) then) =
      __$$ProductsStateSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? msg});
}

/// @nodoc
class __$$ProductsStateSuccessImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateSuccessImpl>
    implements _$$ProductsStateSuccessImplCopyWith<$Res> {
  __$$ProductsStateSuccessImplCopyWithImpl(_$ProductsStateSuccessImpl _value,
      $Res Function(_$ProductsStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(_$ProductsStateSuccessImpl(
      freezed == msg
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ProductsStateSuccessImpl implements ProductsStateSuccess {
  const _$ProductsStateSuccessImpl(this.msg);

  @override
  final String? msg;

  @override
  String toString() {
    return 'ProductsState.success(msg: $msg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateSuccessImpl &&
            (identical(other.msg, msg) || other.msg == msg));
  }

  @override
  int get hashCode => Object.hash(runtimeType, msg);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateSuccessImplCopyWith<_$ProductsStateSuccessImpl>
      get copyWith =>
          __$$ProductsStateSuccessImplCopyWithImpl<_$ProductsStateSuccessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return success(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return success?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class ProductsStateSuccess implements ProductsState {
  const factory ProductsStateSuccess(final String? msg) =
      _$ProductsStateSuccessImpl;

  String? get msg;
  @JsonKey(ignore: true)
  _$$ProductsStateSuccessImplCopyWith<_$ProductsStateSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateAddedImplCopyWith<$Res> {
  factory _$$ProductsStateAddedImplCopyWith(_$ProductsStateAddedImpl value,
          $Res Function(_$ProductsStateAddedImpl) then) =
      __$$ProductsStateAddedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic data});
}

/// @nodoc
class __$$ProductsStateAddedImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateAddedImpl>
    implements _$$ProductsStateAddedImplCopyWith<$Res> {
  __$$ProductsStateAddedImplCopyWithImpl(_$ProductsStateAddedImpl _value,
      $Res Function(_$ProductsStateAddedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$ProductsStateAddedImpl(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$ProductsStateAddedImpl implements ProductsStateAdded {
  const _$ProductsStateAddedImpl(this.data);

  @override
  final dynamic data;

  @override
  String toString() {
    return 'ProductsState.productAdded(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateAddedImpl &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateAddedImplCopyWith<_$ProductsStateAddedImpl> get copyWith =>
      __$$ProductsStateAddedImplCopyWithImpl<_$ProductsStateAddedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return productAdded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return productAdded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productAdded != null) {
      return productAdded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return productAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return productAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productAdded != null) {
      return productAdded(this);
    }
    return orElse();
  }
}

abstract class ProductsStateAdded implements ProductsState {
  const factory ProductsStateAdded(final dynamic data) =
      _$ProductsStateAddedImpl;

  dynamic get data;
  @JsonKey(ignore: true)
  _$$ProductsStateAddedImplCopyWith<_$ProductsStateAddedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateSubProductAddedImplCopyWith<$Res> {
  factory _$$ProductsStateSubProductAddedImplCopyWith(
          _$ProductsStateSubProductAddedImpl value,
          $Res Function(_$ProductsStateSubProductAddedImpl) then) =
      __$$ProductsStateSubProductAddedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic data});
}

/// @nodoc
class __$$ProductsStateSubProductAddedImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res,
        _$ProductsStateSubProductAddedImpl>
    implements _$$ProductsStateSubProductAddedImplCopyWith<$Res> {
  __$$ProductsStateSubProductAddedImplCopyWithImpl(
      _$ProductsStateSubProductAddedImpl _value,
      $Res Function(_$ProductsStateSubProductAddedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$ProductsStateSubProductAddedImpl(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$ProductsStateSubProductAddedImpl
    implements ProductsStateSubProductAdded {
  const _$ProductsStateSubProductAddedImpl(this.data);

  @override
  final dynamic data;

  @override
  String toString() {
    return 'ProductsState.subProductAdded(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateSubProductAddedImpl &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateSubProductAddedImplCopyWith<
          _$ProductsStateSubProductAddedImpl>
      get copyWith => __$$ProductsStateSubProductAddedImplCopyWithImpl<
          _$ProductsStateSubProductAddedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return subProductAdded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return subProductAdded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (subProductAdded != null) {
      return subProductAdded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return subProductAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return subProductAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (subProductAdded != null) {
      return subProductAdded(this);
    }
    return orElse();
  }
}

abstract class ProductsStateSubProductAdded implements ProductsState {
  const factory ProductsStateSubProductAdded(final dynamic data) =
      _$ProductsStateSubProductAddedImpl;

  dynamic get data;
  @JsonKey(ignore: true)
  _$$ProductsStateSubProductAddedImplCopyWith<
          _$ProductsStateSubProductAddedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateParentCategoriesImplCopyWith<$Res> {
  factory _$$ProductsStateParentCategoriesImplCopyWith(
          _$ProductsStateParentCategoriesImpl value,
          $Res Function(_$ProductsStateParentCategoriesImpl) then) =
      __$$ProductsStateParentCategoriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Category> categories});
}

/// @nodoc
class __$$ProductsStateParentCategoriesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res,
        _$ProductsStateParentCategoriesImpl>
    implements _$$ProductsStateParentCategoriesImplCopyWith<$Res> {
  __$$ProductsStateParentCategoriesImplCopyWithImpl(
      _$ProductsStateParentCategoriesImpl _value,
      $Res Function(_$ProductsStateParentCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categories = null,
  }) {
    return _then(_$ProductsStateParentCategoriesImpl(
      null == categories
          ? _value._categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<Category>,
    ));
  }
}

/// @nodoc

class _$ProductsStateParentCategoriesImpl
    implements ProductsStateParentCategories {
  const _$ProductsStateParentCategoriesImpl(final List<Category> categories)
      : _categories = categories;

  final List<Category> _categories;
  @override
  List<Category> get categories {
    if (_categories is EqualUnmodifiableListView) return _categories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categories);
  }

  @override
  String toString() {
    return 'ProductsState.parentCategories(categories: $categories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateParentCategoriesImpl &&
            const DeepCollectionEquality()
                .equals(other._categories, _categories));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_categories));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateParentCategoriesImplCopyWith<
          _$ProductsStateParentCategoriesImpl>
      get copyWith => __$$ProductsStateParentCategoriesImplCopyWithImpl<
          _$ProductsStateParentCategoriesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return parentCategories(this.categories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return parentCategories?.call(this.categories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (parentCategories != null) {
      return parentCategories(this.categories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return parentCategories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return parentCategories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (parentCategories != null) {
      return parentCategories(this);
    }
    return orElse();
  }
}

abstract class ProductsStateParentCategories implements ProductsState {
  const factory ProductsStateParentCategories(final List<Category> categories) =
      _$ProductsStateParentCategoriesImpl;

  List<Category> get categories;
  @JsonKey(ignore: true)
  _$$ProductsStateParentCategoriesImplCopyWith<
          _$ProductsStateParentCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateCategoriesImplCopyWith<$Res> {
  factory _$$ProductsStateCategoriesImplCopyWith(
          _$ProductsStateCategoriesImpl value,
          $Res Function(_$ProductsStateCategoriesImpl) then) =
      __$$ProductsStateCategoriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Category> categories});
}

/// @nodoc
class __$$ProductsStateCategoriesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateCategoriesImpl>
    implements _$$ProductsStateCategoriesImplCopyWith<$Res> {
  __$$ProductsStateCategoriesImplCopyWithImpl(
      _$ProductsStateCategoriesImpl _value,
      $Res Function(_$ProductsStateCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categories = null,
  }) {
    return _then(_$ProductsStateCategoriesImpl(
      null == categories
          ? _value._categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<Category>,
    ));
  }
}

/// @nodoc

class _$ProductsStateCategoriesImpl implements ProductsStateCategories {
  const _$ProductsStateCategoriesImpl(final List<Category> categories)
      : _categories = categories;

  final List<Category> _categories;
  @override
  List<Category> get categories {
    if (_categories is EqualUnmodifiableListView) return _categories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categories);
  }

  @override
  String toString() {
    return 'ProductsState.categories(categories: $categories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateCategoriesImpl &&
            const DeepCollectionEquality()
                .equals(other._categories, _categories));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_categories));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateCategoriesImplCopyWith<_$ProductsStateCategoriesImpl>
      get copyWith => __$$ProductsStateCategoriesImplCopyWithImpl<
          _$ProductsStateCategoriesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return categories(this.categories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return categories?.call(this.categories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (categories != null) {
      return categories(this.categories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return categories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return categories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (categories != null) {
      return categories(this);
    }
    return orElse();
  }
}

abstract class ProductsStateCategories implements ProductsState {
  const factory ProductsStateCategories(final List<Category> categories) =
      _$ProductsStateCategoriesImpl;

  List<Category> get categories;
  @JsonKey(ignore: true)
  _$$ProductsStateCategoriesImplCopyWith<_$ProductsStateCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateProductsImplCopyWith<$Res> {
  factory _$$ProductsStateProductsImplCopyWith(
          _$ProductsStateProductsImpl value,
          $Res Function(_$ProductsStateProductsImpl) then) =
      __$$ProductsStateProductsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Product> products});
}

/// @nodoc
class __$$ProductsStateProductsImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateProductsImpl>
    implements _$$ProductsStateProductsImplCopyWith<$Res> {
  __$$ProductsStateProductsImplCopyWithImpl(_$ProductsStateProductsImpl _value,
      $Res Function(_$ProductsStateProductsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? products = null,
  }) {
    return _then(_$ProductsStateProductsImpl(
      null == products
          ? _value._products
          : products // ignore: cast_nullable_to_non_nullable
              as List<Product>,
    ));
  }
}

/// @nodoc

class _$ProductsStateProductsImpl implements ProductsStateProducts {
  const _$ProductsStateProductsImpl(final List<Product> products)
      : _products = products;

  final List<Product> _products;
  @override
  List<Product> get products {
    if (_products is EqualUnmodifiableListView) return _products;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_products);
  }

  @override
  String toString() {
    return 'ProductsState.products(products: $products)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateProductsImpl &&
            const DeepCollectionEquality().equals(other._products, _products));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_products));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateProductsImplCopyWith<_$ProductsStateProductsImpl>
      get copyWith => __$$ProductsStateProductsImplCopyWithImpl<
          _$ProductsStateProductsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return products(this.products);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return products?.call(this.products);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (products != null) {
      return products(this.products);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return products(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return products?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (products != null) {
      return products(this);
    }
    return orElse();
  }
}

abstract class ProductsStateProducts implements ProductsState {
  const factory ProductsStateProducts(final List<Product> products) =
      _$ProductsStateProductsImpl;

  List<Product> get products;
  @JsonKey(ignore: true)
  _$$ProductsStateProductsImplCopyWith<_$ProductsStateProductsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateProductImagesImplCopyWith<$Res> {
  factory _$$ProductsStateProductImagesImplCopyWith(
          _$ProductsStateProductImagesImpl value,
          $Res Function(_$ProductsStateProductImagesImpl) then) =
      __$$ProductsStateProductImagesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String>? productImages});
}

/// @nodoc
class __$$ProductsStateProductImagesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateProductImagesImpl>
    implements _$$ProductsStateProductImagesImplCopyWith<$Res> {
  __$$ProductsStateProductImagesImplCopyWithImpl(
      _$ProductsStateProductImagesImpl _value,
      $Res Function(_$ProductsStateProductImagesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productImages = freezed,
  }) {
    return _then(_$ProductsStateProductImagesImpl(
      freezed == productImages
          ? _value._productImages
          : productImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$ProductsStateProductImagesImpl implements ProductsStateProductImages {
  const _$ProductsStateProductImagesImpl(final List<String>? productImages)
      : _productImages = productImages;

  final List<String>? _productImages;
  @override
  List<String>? get productImages {
    final value = _productImages;
    if (value == null) return null;
    if (_productImages is EqualUnmodifiableListView) return _productImages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ProductsState.productImages(productImages: $productImages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateProductImagesImpl &&
            const DeepCollectionEquality()
                .equals(other._productImages, _productImages));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_productImages));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateProductImagesImplCopyWith<_$ProductsStateProductImagesImpl>
      get copyWith => __$$ProductsStateProductImagesImplCopyWithImpl<
          _$ProductsStateProductImagesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return productImages(this.productImages);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return productImages?.call(this.productImages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productImages != null) {
      return productImages(this.productImages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return productImages(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return productImages?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productImages != null) {
      return productImages(this);
    }
    return orElse();
  }
}

abstract class ProductsStateProductImages implements ProductsState {
  const factory ProductsStateProductImages(final List<String>? productImages) =
      _$ProductsStateProductImagesImpl;

  List<String>? get productImages;
  @JsonKey(ignore: true)
  _$$ProductsStateProductImagesImplCopyWith<_$ProductsStateProductImagesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateUomImplCopyWith<$Res> {
  factory _$$ProductsStateUomImplCopyWith(_$ProductsStateUomImpl value,
          $Res Function(_$ProductsStateUomImpl) then) =
      __$$ProductsStateUomImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Uom> uom});
}

/// @nodoc
class __$$ProductsStateUomImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateUomImpl>
    implements _$$ProductsStateUomImplCopyWith<$Res> {
  __$$ProductsStateUomImplCopyWithImpl(_$ProductsStateUomImpl _value,
      $Res Function(_$ProductsStateUomImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uom = null,
  }) {
    return _then(_$ProductsStateUomImpl(
      null == uom
          ? _value._uom
          : uom // ignore: cast_nullable_to_non_nullable
              as List<Uom>,
    ));
  }
}

/// @nodoc

class _$ProductsStateUomImpl implements ProductsStateUom {
  const _$ProductsStateUomImpl(final List<Uom> uom) : _uom = uom;

  final List<Uom> _uom;
  @override
  List<Uom> get uom {
    if (_uom is EqualUnmodifiableListView) return _uom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_uom);
  }

  @override
  String toString() {
    return 'ProductsState.uom(uom: $uom)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateUomImpl &&
            const DeepCollectionEquality().equals(other._uom, _uom));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_uom));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateUomImplCopyWith<_$ProductsStateUomImpl> get copyWith =>
      __$$ProductsStateUomImplCopyWithImpl<_$ProductsStateUomImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return uom(this.uom);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return uom?.call(this.uom);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (uom != null) {
      return uom(this.uom);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return uom(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return uom?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (uom != null) {
      return uom(this);
    }
    return orElse();
  }
}

abstract class ProductsStateUom implements ProductsState {
  const factory ProductsStateUom(final List<Uom> uom) = _$ProductsStateUomImpl;

  List<Uom> get uom;
  @JsonKey(ignore: true)
  _$$ProductsStateUomImplCopyWith<_$ProductsStateUomImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateBrandsImplCopyWith<$Res> {
  factory _$$ProductsStateBrandsImplCopyWith(_$ProductsStateBrandsImpl value,
          $Res Function(_$ProductsStateBrandsImpl) then) =
      __$$ProductsStateBrandsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Brand> brands});
}

/// @nodoc
class __$$ProductsStateBrandsImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateBrandsImpl>
    implements _$$ProductsStateBrandsImplCopyWith<$Res> {
  __$$ProductsStateBrandsImplCopyWithImpl(_$ProductsStateBrandsImpl _value,
      $Res Function(_$ProductsStateBrandsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? brands = null,
  }) {
    return _then(_$ProductsStateBrandsImpl(
      null == brands
          ? _value._brands
          : brands // ignore: cast_nullable_to_non_nullable
              as List<Brand>,
    ));
  }
}

/// @nodoc

class _$ProductsStateBrandsImpl implements ProductsStateBrands {
  const _$ProductsStateBrandsImpl(final List<Brand> brands) : _brands = brands;

  final List<Brand> _brands;
  @override
  List<Brand> get brands {
    if (_brands is EqualUnmodifiableListView) return _brands;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_brands);
  }

  @override
  String toString() {
    return 'ProductsState.brands(brands: $brands)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateBrandsImpl &&
            const DeepCollectionEquality().equals(other._brands, _brands));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_brands));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateBrandsImplCopyWith<_$ProductsStateBrandsImpl> get copyWith =>
      __$$ProductsStateBrandsImplCopyWithImpl<_$ProductsStateBrandsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return brands(this.brands);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return brands?.call(this.brands);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (brands != null) {
      return brands(this.brands);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return brands(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return brands?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (brands != null) {
      return brands(this);
    }
    return orElse();
  }
}

abstract class ProductsStateBrands implements ProductsState {
  const factory ProductsStateBrands(final List<Brand> brands) =
      _$ProductsStateBrandsImpl;

  List<Brand> get brands;
  @JsonKey(ignore: true)
  _$$ProductsStateBrandsImplCopyWith<_$ProductsStateBrandsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateCountriesImplCopyWith<$Res> {
  factory _$$ProductsStateCountriesImplCopyWith(
          _$ProductsStateCountriesImpl value,
          $Res Function(_$ProductsStateCountriesImpl) then) =
      __$$ProductsStateCountriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Country> countries});
}

/// @nodoc
class __$$ProductsStateCountriesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateCountriesImpl>
    implements _$$ProductsStateCountriesImplCopyWith<$Res> {
  __$$ProductsStateCountriesImplCopyWithImpl(
      _$ProductsStateCountriesImpl _value,
      $Res Function(_$ProductsStateCountriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countries = null,
  }) {
    return _then(_$ProductsStateCountriesImpl(
      null == countries
          ? _value._countries
          : countries // ignore: cast_nullable_to_non_nullable
              as List<Country>,
    ));
  }
}

/// @nodoc

class _$ProductsStateCountriesImpl implements ProductsStateCountries {
  const _$ProductsStateCountriesImpl(final List<Country> countries)
      : _countries = countries;

  final List<Country> _countries;
  @override
  List<Country> get countries {
    if (_countries is EqualUnmodifiableListView) return _countries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_countries);
  }

  @override
  String toString() {
    return 'ProductsState.countries(countries: $countries)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateCountriesImpl &&
            const DeepCollectionEquality()
                .equals(other._countries, _countries));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_countries));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateCountriesImplCopyWith<_$ProductsStateCountriesImpl>
      get copyWith => __$$ProductsStateCountriesImplCopyWithImpl<
          _$ProductsStateCountriesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return countries(this.countries);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return countries?.call(this.countries);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries(this.countries);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return countries(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return countries?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries(this);
    }
    return orElse();
  }
}

abstract class ProductsStateCountries implements ProductsState {
  const factory ProductsStateCountries(final List<Country> countries) =
      _$ProductsStateCountriesImpl;

  List<Country> get countries;
  @JsonKey(ignore: true)
  _$$ProductsStateCountriesImplCopyWith<_$ProductsStateCountriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateTypesImplCopyWith<$Res> {
  factory _$$ProductsStateTypesImplCopyWith(_$ProductsStateTypesImpl value,
          $Res Function(_$ProductsStateTypesImpl) then) =
      __$$ProductsStateTypesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ProductType> productTypes});
}

/// @nodoc
class __$$ProductsStateTypesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateTypesImpl>
    implements _$$ProductsStateTypesImplCopyWith<$Res> {
  __$$ProductsStateTypesImplCopyWithImpl(_$ProductsStateTypesImpl _value,
      $Res Function(_$ProductsStateTypesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productTypes = null,
  }) {
    return _then(_$ProductsStateTypesImpl(
      null == productTypes
          ? _value._productTypes
          : productTypes // ignore: cast_nullable_to_non_nullable
              as List<ProductType>,
    ));
  }
}

/// @nodoc

class _$ProductsStateTypesImpl implements ProductsStateTypes {
  const _$ProductsStateTypesImpl(final List<ProductType> productTypes)
      : _productTypes = productTypes;

  final List<ProductType> _productTypes;
  @override
  List<ProductType> get productTypes {
    if (_productTypes is EqualUnmodifiableListView) return _productTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_productTypes);
  }

  @override
  String toString() {
    return 'ProductsState.productTypes(productTypes: $productTypes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateTypesImpl &&
            const DeepCollectionEquality()
                .equals(other._productTypes, _productTypes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_productTypes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateTypesImplCopyWith<_$ProductsStateTypesImpl> get copyWith =>
      __$$ProductsStateTypesImplCopyWithImpl<_$ProductsStateTypesImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return productTypes(this.productTypes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return productTypes?.call(this.productTypes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productTypes != null) {
      return productTypes(this.productTypes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return productTypes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return productTypes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (productTypes != null) {
      return productTypes(this);
    }
    return orElse();
  }
}

abstract class ProductsStateTypes implements ProductsState {
  const factory ProductsStateTypes(final List<ProductType> productTypes) =
      _$ProductsStateTypesImpl;

  List<ProductType> get productTypes;
  @JsonKey(ignore: true)
  _$$ProductsStateTypesImplCopyWith<_$ProductsStateTypesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateDiscountTypesImplCopyWith<$Res> {
  factory _$$ProductsStateDiscountTypesImplCopyWith(
          _$ProductsStateDiscountTypesImpl value,
          $Res Function(_$ProductsStateDiscountTypesImpl) then) =
      __$$ProductsStateDiscountTypesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<DiscountType> discountTypes});
}

/// @nodoc
class __$$ProductsStateDiscountTypesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateDiscountTypesImpl>
    implements _$$ProductsStateDiscountTypesImplCopyWith<$Res> {
  __$$ProductsStateDiscountTypesImplCopyWithImpl(
      _$ProductsStateDiscountTypesImpl _value,
      $Res Function(_$ProductsStateDiscountTypesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? discountTypes = null,
  }) {
    return _then(_$ProductsStateDiscountTypesImpl(
      null == discountTypes
          ? _value._discountTypes
          : discountTypes // ignore: cast_nullable_to_non_nullable
              as List<DiscountType>,
    ));
  }
}

/// @nodoc

class _$ProductsStateDiscountTypesImpl implements ProductsStateDiscountTypes {
  const _$ProductsStateDiscountTypesImpl(final List<DiscountType> discountTypes)
      : _discountTypes = discountTypes;

  final List<DiscountType> _discountTypes;
  @override
  List<DiscountType> get discountTypes {
    if (_discountTypes is EqualUnmodifiableListView) return _discountTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_discountTypes);
  }

  @override
  String toString() {
    return 'ProductsState.discountType(discountTypes: $discountTypes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateDiscountTypesImpl &&
            const DeepCollectionEquality()
                .equals(other._discountTypes, _discountTypes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_discountTypes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateDiscountTypesImplCopyWith<_$ProductsStateDiscountTypesImpl>
      get copyWith => __$$ProductsStateDiscountTypesImplCopyWithImpl<
          _$ProductsStateDiscountTypesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return discountType(discountTypes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return discountType?.call(discountTypes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (discountType != null) {
      return discountType(discountTypes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return discountType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return discountType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (discountType != null) {
      return discountType(this);
    }
    return orElse();
  }
}

abstract class ProductsStateDiscountTypes implements ProductsState {
  const factory ProductsStateDiscountTypes(
          final List<DiscountType> discountTypes) =
      _$ProductsStateDiscountTypesImpl;

  List<DiscountType> get discountTypes;
  @JsonKey(ignore: true)
  _$$ProductsStateDiscountTypesImplCopyWith<_$ProductsStateDiscountTypesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateVariantsImplCopyWith<$Res> {
  factory _$$ProductsStateVariantsImplCopyWith(
          _$ProductsStateVariantsImpl value,
          $Res Function(_$ProductsStateVariantsImpl) then) =
      __$$ProductsStateVariantsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ProductVariant> variants});
}

/// @nodoc
class __$$ProductsStateVariantsImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateVariantsImpl>
    implements _$$ProductsStateVariantsImplCopyWith<$Res> {
  __$$ProductsStateVariantsImplCopyWithImpl(_$ProductsStateVariantsImpl _value,
      $Res Function(_$ProductsStateVariantsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? variants = null,
  }) {
    return _then(_$ProductsStateVariantsImpl(
      null == variants
          ? _value._variants
          : variants // ignore: cast_nullable_to_non_nullable
              as List<ProductVariant>,
    ));
  }
}

/// @nodoc

class _$ProductsStateVariantsImpl implements ProductsStateVariants {
  const _$ProductsStateVariantsImpl(final List<ProductVariant> variants)
      : _variants = variants;

  final List<ProductVariant> _variants;
  @override
  List<ProductVariant> get variants {
    if (_variants is EqualUnmodifiableListView) return _variants;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_variants);
  }

  @override
  String toString() {
    return 'ProductsState.variants(variants: $variants)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateVariantsImpl &&
            const DeepCollectionEquality().equals(other._variants, _variants));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_variants));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateVariantsImplCopyWith<_$ProductsStateVariantsImpl>
      get copyWith => __$$ProductsStateVariantsImplCopyWithImpl<
          _$ProductsStateVariantsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return variants(this.variants);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return variants?.call(this.variants);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (variants != null) {
      return variants(this.variants);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return variants(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return variants?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (variants != null) {
      return variants(this);
    }
    return orElse();
  }
}

abstract class ProductsStateVariants implements ProductsState {
  const factory ProductsStateVariants(final List<ProductVariant> variants) =
      _$ProductsStateVariantsImpl;

  List<ProductVariant> get variants;
  @JsonKey(ignore: true)
  _$$ProductsStateVariantsImplCopyWith<_$ProductsStateVariantsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateLocalVariantsImplCopyWith<$Res> {
  factory _$$ProductsStateLocalVariantsImplCopyWith(
          _$ProductsStateLocalVariantsImpl value,
          $Res Function(_$ProductsStateLocalVariantsImpl) then) =
      __$$ProductsStateLocalVariantsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Map<ProductVariant, String>> variants});
}

/// @nodoc
class __$$ProductsStateLocalVariantsImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res, _$ProductsStateLocalVariantsImpl>
    implements _$$ProductsStateLocalVariantsImplCopyWith<$Res> {
  __$$ProductsStateLocalVariantsImplCopyWithImpl(
      _$ProductsStateLocalVariantsImpl _value,
      $Res Function(_$ProductsStateLocalVariantsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? variants = null,
  }) {
    return _then(_$ProductsStateLocalVariantsImpl(
      null == variants
          ? _value._variants
          : variants // ignore: cast_nullable_to_non_nullable
              as List<Map<ProductVariant, String>>,
    ));
  }
}

/// @nodoc

class _$ProductsStateLocalVariantsImpl implements ProductsStateLocalVariants {
  const _$ProductsStateLocalVariantsImpl(
      final List<Map<ProductVariant, String>> variants)
      : _variants = variants;

  final List<Map<ProductVariant, String>> _variants;
  @override
  List<Map<ProductVariant, String>> get variants {
    if (_variants is EqualUnmodifiableListView) return _variants;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_variants);
  }

  @override
  String toString() {
    return 'ProductsState.locallyAddedVariants(variants: $variants)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateLocalVariantsImpl &&
            const DeepCollectionEquality().equals(other._variants, _variants));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_variants));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateLocalVariantsImplCopyWith<_$ProductsStateLocalVariantsImpl>
      get copyWith => __$$ProductsStateLocalVariantsImplCopyWithImpl<
          _$ProductsStateLocalVariantsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return locallyAddedVariants(this.variants);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return locallyAddedVariants?.call(this.variants);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (locallyAddedVariants != null) {
      return locallyAddedVariants(this.variants);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return locallyAddedVariants(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return locallyAddedVariants?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (locallyAddedVariants != null) {
      return locallyAddedVariants(this);
    }
    return orElse();
  }
}

abstract class ProductsStateLocalVariants implements ProductsState {
  const factory ProductsStateLocalVariants(
          final List<Map<ProductVariant, String>> variants) =
      _$ProductsStateLocalVariantsImpl;

  List<Map<ProductVariant, String>> get variants;
  @JsonKey(ignore: true)
  _$$ProductsStateLocalVariantsImplCopyWith<_$ProductsStateLocalVariantsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductsStateCategoriesChildCategoriesImplCopyWith<$Res> {
  factory _$$ProductsStateCategoriesChildCategoriesImplCopyWith(
          _$ProductsStateCategoriesChildCategoriesImpl value,
          $Res Function(_$ProductsStateCategoriesChildCategoriesImpl) then) =
      __$$ProductsStateCategoriesChildCategoriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ParentCategoryWithCategories> parentCategoryWithCategories});
}

/// @nodoc
class __$$ProductsStateCategoriesChildCategoriesImplCopyWithImpl<$Res>
    extends _$ProductsStateCopyWithImpl<$Res,
        _$ProductsStateCategoriesChildCategoriesImpl>
    implements _$$ProductsStateCategoriesChildCategoriesImplCopyWith<$Res> {
  __$$ProductsStateCategoriesChildCategoriesImplCopyWithImpl(
      _$ProductsStateCategoriesChildCategoriesImpl _value,
      $Res Function(_$ProductsStateCategoriesChildCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? parentCategoryWithCategories = null,
  }) {
    return _then(_$ProductsStateCategoriesChildCategoriesImpl(
      null == parentCategoryWithCategories
          ? _value._parentCategoryWithCategories
          : parentCategoryWithCategories // ignore: cast_nullable_to_non_nullable
              as List<ParentCategoryWithCategories>,
    ));
  }
}

/// @nodoc

class _$ProductsStateCategoriesChildCategoriesImpl
    implements ProductsStateCategoriesChildCategories {
  const _$ProductsStateCategoriesChildCategoriesImpl(
      final List<ParentCategoryWithCategories> parentCategoryWithCategories)
      : _parentCategoryWithCategories = parentCategoryWithCategories;

  final List<ParentCategoryWithCategories> _parentCategoryWithCategories;
  @override
  List<ParentCategoryWithCategories> get parentCategoryWithCategories {
    if (_parentCategoryWithCategories is EqualUnmodifiableListView)
      return _parentCategoryWithCategories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parentCategoryWithCategories);
  }

  @override
  String toString() {
    return 'ProductsState.parentCategoryWithCategories(parentCategoryWithCategories: $parentCategoryWithCategories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductsStateCategoriesChildCategoriesImpl &&
            const DeepCollectionEquality().equals(
                other._parentCategoryWithCategories,
                _parentCategoryWithCategories));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_parentCategoryWithCategories));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductsStateCategoriesChildCategoriesImplCopyWith<
          _$ProductsStateCategoriesChildCategoriesImpl>
      get copyWith =>
          __$$ProductsStateCategoriesChildCategoriesImplCopyWithImpl<
              _$ProductsStateCategoriesChildCategoriesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function(String messages) error,
    required TResult Function(String? msg) success,
    required TResult Function(dynamic data) productAdded,
    required TResult Function(dynamic data) subProductAdded,
    required TResult Function(List<Category> categories) parentCategories,
    required TResult Function(List<Category> categories) categories,
    required TResult Function(List<Product> products) products,
    required TResult Function(List<String>? productImages) productImages,
    required TResult Function(List<Uom> uom) uom,
    required TResult Function(List<Brand> brands) brands,
    required TResult Function(List<Country> countries) countries,
    required TResult Function(List<ProductType> productTypes) productTypes,
    required TResult Function(List<DiscountType> discountTypes) discountType,
    required TResult Function(List<ProductVariant> variants) variants,
    required TResult Function(List<Map<ProductVariant, String>> variants)
        locallyAddedVariants,
    required TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)
        parentCategoryWithCategories,
  }) {
    return parentCategoryWithCategories(this.parentCategoryWithCategories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? loading,
    TResult? Function(String messages)? error,
    TResult? Function(String? msg)? success,
    TResult? Function(dynamic data)? productAdded,
    TResult? Function(dynamic data)? subProductAdded,
    TResult? Function(List<Category> categories)? parentCategories,
    TResult? Function(List<Category> categories)? categories,
    TResult? Function(List<Product> products)? products,
    TResult? Function(List<String>? productImages)? productImages,
    TResult? Function(List<Uom> uom)? uom,
    TResult? Function(List<Brand> brands)? brands,
    TResult? Function(List<Country> countries)? countries,
    TResult? Function(List<ProductType> productTypes)? productTypes,
    TResult? Function(List<DiscountType> discountTypes)? discountType,
    TResult? Function(List<ProductVariant> variants)? variants,
    TResult? Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult? Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
  }) {
    return parentCategoryWithCategories
        ?.call(this.parentCategoryWithCategories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function(String messages)? error,
    TResult Function(String? msg)? success,
    TResult Function(dynamic data)? productAdded,
    TResult Function(dynamic data)? subProductAdded,
    TResult Function(List<Category> categories)? parentCategories,
    TResult Function(List<Category> categories)? categories,
    TResult Function(List<Product> products)? products,
    TResult Function(List<String>? productImages)? productImages,
    TResult Function(List<Uom> uom)? uom,
    TResult Function(List<Brand> brands)? brands,
    TResult Function(List<Country> countries)? countries,
    TResult Function(List<ProductType> productTypes)? productTypes,
    TResult Function(List<DiscountType> discountTypes)? discountType,
    TResult Function(List<ProductVariant> variants)? variants,
    TResult Function(List<Map<ProductVariant, String>> variants)?
        locallyAddedVariants,
    TResult Function(
            List<ParentCategoryWithCategories> parentCategoryWithCategories)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (parentCategoryWithCategories != null) {
      return parentCategoryWithCategories(this.parentCategoryWithCategories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductsStateInit value) init,
    required TResult Function(ProductsStateLoading value) loading,
    required TResult Function(ProductsStateError value) error,
    required TResult Function(ProductsStateSuccess value) success,
    required TResult Function(ProductsStateAdded value) productAdded,
    required TResult Function(ProductsStateSubProductAdded value)
        subProductAdded,
    required TResult Function(ProductsStateParentCategories value)
        parentCategories,
    required TResult Function(ProductsStateCategories value) categories,
    required TResult Function(ProductsStateProducts value) products,
    required TResult Function(ProductsStateProductImages value) productImages,
    required TResult Function(ProductsStateUom value) uom,
    required TResult Function(ProductsStateBrands value) brands,
    required TResult Function(ProductsStateCountries value) countries,
    required TResult Function(ProductsStateTypes value) productTypes,
    required TResult Function(ProductsStateDiscountTypes value) discountType,
    required TResult Function(ProductsStateVariants value) variants,
    required TResult Function(ProductsStateLocalVariants value)
        locallyAddedVariants,
    required TResult Function(ProductsStateCategoriesChildCategories value)
        parentCategoryWithCategories,
  }) {
    return parentCategoryWithCategories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductsStateInit value)? init,
    TResult? Function(ProductsStateLoading value)? loading,
    TResult? Function(ProductsStateError value)? error,
    TResult? Function(ProductsStateSuccess value)? success,
    TResult? Function(ProductsStateAdded value)? productAdded,
    TResult? Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult? Function(ProductsStateParentCategories value)? parentCategories,
    TResult? Function(ProductsStateCategories value)? categories,
    TResult? Function(ProductsStateProducts value)? products,
    TResult? Function(ProductsStateProductImages value)? productImages,
    TResult? Function(ProductsStateUom value)? uom,
    TResult? Function(ProductsStateBrands value)? brands,
    TResult? Function(ProductsStateCountries value)? countries,
    TResult? Function(ProductsStateTypes value)? productTypes,
    TResult? Function(ProductsStateDiscountTypes value)? discountType,
    TResult? Function(ProductsStateVariants value)? variants,
    TResult? Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult? Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
  }) {
    return parentCategoryWithCategories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductsStateInit value)? init,
    TResult Function(ProductsStateLoading value)? loading,
    TResult Function(ProductsStateError value)? error,
    TResult Function(ProductsStateSuccess value)? success,
    TResult Function(ProductsStateAdded value)? productAdded,
    TResult Function(ProductsStateSubProductAdded value)? subProductAdded,
    TResult Function(ProductsStateParentCategories value)? parentCategories,
    TResult Function(ProductsStateCategories value)? categories,
    TResult Function(ProductsStateProducts value)? products,
    TResult Function(ProductsStateProductImages value)? productImages,
    TResult Function(ProductsStateUom value)? uom,
    TResult Function(ProductsStateBrands value)? brands,
    TResult Function(ProductsStateCountries value)? countries,
    TResult Function(ProductsStateTypes value)? productTypes,
    TResult Function(ProductsStateDiscountTypes value)? discountType,
    TResult Function(ProductsStateVariants value)? variants,
    TResult Function(ProductsStateLocalVariants value)? locallyAddedVariants,
    TResult Function(ProductsStateCategoriesChildCategories value)?
        parentCategoryWithCategories,
    required TResult orElse(),
  }) {
    if (parentCategoryWithCategories != null) {
      return parentCategoryWithCategories(this);
    }
    return orElse();
  }
}

abstract class ProductsStateCategoriesChildCategories implements ProductsState {
  const factory ProductsStateCategoriesChildCategories(
          final List<ParentCategoryWithCategories>
              parentCategoryWithCategories) =
      _$ProductsStateCategoriesChildCategoriesImpl;

  List<ParentCategoryWithCategories> get parentCategoryWithCategories;
  @JsonKey(ignore: true)
  _$$ProductsStateCategoriesChildCategoriesImplCopyWith<
          _$ProductsStateCategoriesChildCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}
